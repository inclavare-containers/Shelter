#!/usr/bin/env bash

. /etc/shelter.d/00_logger

SHELTER_CONF="/etc/shelter.conf"
SHELTER_CONF_DIR="/etc/shelter.d"
SHELTER_INITRD_CONF_DIR="${SHELTER_CONF_DIR}/initrd"
SHELTER_DEFAULT_STAGE="default"
SHELTER_STAGE_DIR="/var/run/shelter/${SHELTER_DEFAULT_STAGE}"
SHELTER_INITRD="${SHELTER_STAGE_DIR}/initrd"
SHELTER_KERNEL="${SHELTER_INITRD}.vmlinuz"
SHELTER_PHRASE="${SHELTER_STAGE_DIR}/phrase"
SHELTER_DISK="${SHELTER_STAGE_DIR}/disk"

EXTRA_DIR="${SHELTER_STAGE_DIR}/extra"
CONF="${SHELTER_STAGE_DIR}/build.conf"

ESSENTIAL_BINARIES=("socat" "busybox" "kmod" "cryptsetup")
ESSENTIAL_FILES=()

SHELTER_TIMEOUT=60

# Function: Display help information
show_help() {
    cat <<EOF
Usage: shelter [Options] SubCommand
Available SubCommands:
    build   Build the shelter
    start   Start the shelter
    stop    Stop the shelter
    exec    exec a shell commad in shelter
    status  Query the status of shelter
    clean   Remove output image and cache

Options:
    -h, --help  Show this help message and exit
EOF
}

randomize() {
    local min=8
    local max=$((2**16 - 1))
    local r

    while true; do
        r=$(od -An -N2 -tu2 /dev/urandom | awk '{print $1}')
        if [[ $r -ge $min && $r -le $max ]]; then
            echo $r
        break
    fi

    done
}

create_phrase() {
    dd if=/dev/urandom of=${SHELTER_PHRASE} bs=1K count=1
    chmod 600 ${SHELTER_PHRASE}
}

add_dir() {
    local dir_path=$1

    if [ ! -d "${EXTRA_DIR}$dir_path" ]; then
        mkdir -p "${EXTRA_DIR}${dir_path}"
    fi
}

copy_file_and_dir_no_resolve_symlink() {
    local src_path=$(realpath -s $1)
    local dst_path=${2:-$src_path}

    # Check if the path exists
    if [ ! -e "$src_path" ]; then
        error "Error: $src_path is not a valid file/dir path"
        exit 1
    fi

    # Check if is a file and already copied
    if ([ -e "${EXTRA_DIR}${dst_path}" ] || [ -L "${EXTRA_DIR}${dst_path}" ]) && ! diff -q "${src_path}" "${EXTRA_DIR}${dst_path}" >/dev/null ; then
        warn "Warn: target path $dst_path already existed in $EXTRA_DIR but different, will be overwrited"
    fi

    if [[ -d "$src_path" ]]; then
        src_path="$src_path"/
        dst_path="$dst_path"/
    fi

    rsync -ap --links "${src_path}" "${EXTRA_DIR}${dst_path}"
}

# Function to copy file (dir is not handled)
copy_file_resolve_symlink() {
    local src_path=$(realpath -s $1)
    local dst_path=${2:-$src_path}

    # Check if the file exists
    if [ ! -e "$src_path" ]; then
        error "Error: $src_path is not a valid file path"
        exit 1
    fi

    # Check if the file already copied
    if [ -e "${EXTRA_DIR}${dst_path}" ] && ! diff -q "${src_path}" "${EXTRA_DIR}${dst_path}" >/dev/null ; then
        warn "Warn: target path $dst_path already existed in $EXTRA_DIR but different, will be overwrited"
    fi

    # Check if file is symbolic link
    if [ -L "$src_path" ]; then
        local target_file_path=$(realpath $1)
        copy_file_resolve_symlink $target_file_path
        add_dir $(dirname $dst_path)
        rsync -a --links "${src_path}" "${EXTRA_DIR}${dst_path}"
        return
    fi

    # Check if file is regular
    if [ -f "$src_path" ]; then
        add_dir $(dirname $dst_path)
        cp -a "${src_path}" "${EXTRA_DIR}${dst_path}"
        return
    fi

    warn "$src_path isn't sysmlink or regular file"
    exit 1
}

# Function to copy shared library
copy_sodeps() {
    local binary_path=$1

    # Check if the file exists
    if [ ! -f "$binary_path" ]; then
        error "Error: $binary_path is not a valid file path"
        exit 1
    fi

    # Use ldd to get dependencies
    local dependencies=$(ldd "$binary_path" 2>/dev/null)

    if [ $? -ne 0 ]; then
        warn "Warn: $binary_path is not a dynamic binary"
        return 0
    fi

    # Parse ldd output and extract and copy dependency paths
    echo "$dependencies" | while read -r line; do
        # Check if the line not contains '=>'
        if ! echo "$line" | grep -q '=>'; then
            # Extract the path, ensuring it starts with /
            local lib_path
            lib_path=$(echo "$line" | awk '{print $1}' | grep '^/')
            if [ -n "$lib_path" ]; then
                copy_file_resolve_symlink "$lib_path"
                continue
            fi
        else
            local lib_path
            lib_path=$(echo "$line" | awk -F '=>' '{print $2}' | awk '{print $1}')
            if [ -n "$lib_path" ] && [ -e "$lib_path" ]; then
                copy_file_resolve_symlink "$lib_path"
            fi
        fi
    done
}

store_stage() {
    local name="$1"
    local val="$2"

    echo -n "${val}" > "${SHELTER_STAGE_DIR}/${name}"
}

get_stage() {
    local name="$1"

    if [ -s "${SHELTER_STAGE_DIR}/${name}" ]; then
        echo "$(cat ${SHELTER_STAGE_DIR}/${name})"
    fi

    echo ""
}

build() {
    # mkosi uses $USER to decide the ownerships of workspace
    if [ "$USER" != "root" ]; then
        warn "WARNING: Running shelter build with root privileges is generally necessary. Try `sudo su -`."
    fi

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -c|--config)
                if [[ ! -z "$2" && "$2" != -* ]]; then
                    CONF="$2"
                    if [ ! -s "$CONF" ]; then
                        error "Error: build config file \"$CONF\" doesn't exist"
                        exit 1
                    fi
                    shift
                else
                    error "Error: --config requires a value." >&2
                    return 1
                fi
                ;;
            *)
                error "Unrecognized option $1"
                return 1
                ;;
        esac
        shift
    done

    debug "Gather files to be copied to initrd and copy into $EXTRA_DIR"
    rm -rf "$EXTRA_DIR"

    if [ ! -d "$EXTRA_DIR" ]; then
        mkdir -p "$EXTRA_DIR"
    fi

    local binaries=()
    local files=()
    local src_dir="$(pwd)"

    if [ -s "$CONF" ]; then
        info "Using $CONF as config file"

        # Read options from the configuration file
        while IFS= read -r line || [ -n "$line" ]; do
            # Trim leading and trailing whitespaces
            line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

            # Check line content and extract values
            if [[ $line == binary=* ]]; then
                # Remove binary= and parentheses
                line=$(echo "$line" | sed 's/^binary=//;s/[()]//g')
                # Split into an array and add to binaries array
                IFS=' ' read -r -a binary_array <<< "$line"
                binaries+=("${binary_array[@]}")
            elif [[ $line == file=* ]]; then
                # Remove file= and parentheses
                line=$(echo "$line" | sed 's/^file=//;s/[()]//g')
                # Split into an array and add to files array
                IFS=' ' read -r -a file_array <<< "$line"
                files+=("${file_array[@]}")
            fi
        done < "$CONF"

        # Assume any relative path in the source is always based on the
        # directory where the config file resides.
        src_dir="$(dirname $CONF)"
    fi

    local src=""
    local dst=""

    # Add the essential binaries
    for i in "${ESSENTIAL_BINARIES[@]}"; do
        i="$(which $i)"
        debug "Copying essential binary $i ..."

        copy_sodeps "$i"
        copy_file_resolve_symlink "$i" "$i"
    done

    local kernel_version="$(uname -r)"

    debug "Building initrd image: ${SHELTER_INITRD}"
    mkosi -f --debug -C "${SHELTER_INITRD_CONF_DIR}" \
    --postinst-script="${SHELTER_INITRD_CONF_DIR}/mkosi.postinst" \
    --output-dir="${SHELTER_STAGE_DIR}" --output="$(basename ${SHELTER_INITRD})" \
    --extra-tree="${EXTRA_DIR}:/extra" \
    --extra-tree="/usr/lib/modules/${kernel_version}:/usr/lib/modules/${kernel_version}" \
    build

    if [ $? -ne 0 ]; then
        error "Error: failed to build initrd image with mkosi"
        exit 1
    fi
    # Parse the mapping between the source and destinaion
    for i in "${binaries[@]}"; do
        if [[ "$i" == *:* ]]; then
            IFS=':' read -r src dst <<< "$i"
        else
            src="$i"
            dst="$i"
        fi

        # Prepend the prefix
        if [[ ! $src =~ ^/ ]]; then
            src="$src_dir/$src"
        fi

        src="$(realpath $src)"

        copy_sodeps $src
        copy_file_resolve_symlink "$src" "$dst"
    done

    for i in "${files[@]}"; do
        if [[ "$i" == *:* ]]; then
            IFS=':' read -r src dst <<< "$i"
        else
            src="$i"
            dst="$i"
        fi

        if [[ ! $src =~ ^/ ]]; then
            src="$src_dir/$src"
        fi

        src="$(realpath $src)"

        copy_file_and_dir_no_resolve_symlink "$src" "$dst"
    done

    # Add the essential files
    for i in "${ESSENTIAL_FILES[@]}"; do
        copy_file_and_dir_no_resolve_symlink "$i"
    done

    debug "Create luks keyfile"
    create_phrase

    debug "Building Disk image: ${SHELTER_DISK}"
    mkosi -f --debug -C "${SHELTER_CONF_DIR}" \
      --build-script="${SHELTER_CONF_DIR}/mkosi.build" \
      --postinst-script="${SHELTER_CONF_DIR}/mkosi.postinst" \
      --output-dir="${SHELTER_STAGE_DIR}" --output="$(basename ${SHELTER_DISK})" \
      --extra-tree="${EXTRA_DIR}:/extra" \
      --extra-tree="/usr/lib/modules/${kernel_version}:/usr/lib/modules/${kernel_version}" \
      --passphrase="${SHELTER_PHRASE}" \
      --repart-dir="${SHELTER_CONF_DIR}/mkosi.repart" \
      build
      
    if [ $? -ne 0 ]; then
        error "Error: failed to build disk image with mkosi"
        exit 1
    fi
}

get_conf() {
    local name="$1"

    toml get --toml-path "${SHELTER_CONF}" "${name}"
}

config_qemu() {
    local bin="$1"
    local mem="$2"
    local kern_cmd="$3"
    local cid="$4"
    local extra_opts="$5"

    if [ x"${bin}" = x"" ]; then
        bin="qemu-system-x86_64"
    fi

    if [ x"${mem}" = x"" ]; then
        mem="4G"
    fi

    kern_cmd="${kern_cmd} console=ttyS0"

    local opts="$(cat <<EOF
-accel kvm -m ${mem} -nographic -cpu host
-kernel '${SHELTER_KERNEL}' -initrd '${SHELTER_INITRD}'
-append '${kern_cmd}'
-device vhost-vsock-pci,guest-cid=${cid}
-drive file='${SHELTER_DISK}',format=raw,if=virtio
EOF
)"
    echo -n "${bin} ${opts} ${extra_opts}"
}

start() {
    local max_user_ns="$(sysctl --binary --quiet user.max_user_namespaces)"

    # Work around the default zero max_user_namespaces value on apasa
    if [ "${max_user_ns}" == "0" ]; then
        warn "Set user.max_user_namespaces to be 766996 forcibly."
        sysctl --write user.max_user_namespaces=766996
    fi
    
    if [[ -s "${SHELTER_INITRD}" && -s "${SHELTER_DISK}" && -s "${SHELTER_KERNEL}" ]]; then
        local cid=$(randomize)
        store_stage "cid" "${cid}"

        local vmm="$(get_conf vmm)"
        local cmd=""
        if [ x"${vmm}" = x"qemu" ]; then
            local bin="$(get_conf ${vmm}.bin)"
            local mem="$(get_conf ${vmm}.mem)"
            local kern_cmdline="$(get_conf ${vmm}.kern_cmdline)"
            local opts="$(get_conf ${vmm}.opts)"

            cmd="$(config_qemu "${bin}" "${mem}" "${kern_cmdline}" "${cid}" "${opts}")"
        fi

        debug "qemu command: $cmd"
        eval cmd=("$cmd")

        systemd-run --user --description=Shelter --unit=shelter.service -p StandardInput=null -G "${cmd[@]}"

        local wait_seconds=${SHELTER_TIMEOUT}
        debug "Now waiting ${wait_seconds} seconds for the guest to open crypt disk ..."
        local is_ready=0
        
        for ((i=${wait_seconds}; i>0; i--))
        do
            if ! is-active; then
                error "Failed to run shelter guest"
                return 1
                fi
        
            if socat -u file:${SHELTER_PHRASE} vsock-connect:${cid}:4321 1>&- 2>&-; then
                # The guest is ready
                is_ready=1
                break
            fi
                sleep 1
        done

        if [[ $is_ready -ne 1 ]]; then
            error "Failed to open shelter guest disk"
            stop
            exit 1
        fi
        debug "The guest is started at CID ${cid}"
    else
        error "The files ${SHELTER_INITRD} or ${SHELTER_KERNEL} or ${SHELTER_DISK} is missing. You may need to run 'shelter build' first."
        exit 1
    fi
}

is-active() {
    systemctl --user -q is-active shelter.service
}

run() {
    start

    debug "The guest is booting"

    local wait_seconds=${SHELTER_TIMEOUT}
    debug "Now waiting ${wait_seconds} seconds for the guest to launch ..."

    local cid="$(get_stage cid)"
    local is_ready=0

    for ((i=${wait_seconds}; i>0; i--))
    do
        if ! is-active; then
            error "Failed to run shelter guest"
            return 1
        fi

        if socat /dev/null vsock-connect:${cid}:4321 1>&- 2>&-; then
            # The guest is ready
            is_ready=1
            break
        fi

        sleep 1
    done

    if [[ $is_ready -ne 1 ]]; then
        error "Failed to run shelter guest"
        stop
        return 1
    fi

    if [[ $1 == "--" ]]; then
        shift
    fi

    debug "Run command in guest: '$@'"
    exec $@

    stop
}

status() {
    if is-active; then
        systemctl --user status shelter.service
        return 0
    fi

    echo "Shelter isn't running"
}

stop() {
    if ! is-active; then
        exit 0;
    fi

    local cid="$(get_stage cid)"

    debug "Send poweroff event to the guest"
    echo "/usr/bin/poweroff" | socat - vsock-connect:${cid}:4321

    local wait_seconds=${SHELTER_TIMEOUT}
    debug "Now waiting ${wait_seconds} seconds for the guest to exit ..."

    for ((i=${wait_seconds}; i>0; i--))
    do
        if ! is-active; then
            debug "Shelter has been smoothly stopped"
            return 0
        fi
        sleep 1
    done

    systemctl --user stop shelter.service
    error "Shelter has been forcibly shut down"
}

exec() {
    if [[ $1 == "--" ]]; then
        shift
    fi

    local cid="$(get_stage cid)"
    echo "$@" | socat - vsock-connect:${cid}:4321
}

clean() {
    mkosi clean
    rm -rf "${EXTRA_DIR}"
}

main() {
    # Check if a subcommand or help option is provided
    if [ $# -lt 1 ]; then
        show_help
        exit 1
    fi

    # Check for --help or -h options
    for arg in "$@"; do
        case $arg in
            -h|--help)
                show_help
                exit 0
                ;;
            --)
                break
                ;;
        esac
    done

    [ -z "${XDG_RUNTIME_DIR}" ] && export XDG_RUNTIME_DIR="/run/user/$(id -u)"
    [ -z "${DBUS_SESSION_BUS_ADDRESS}" ] && export DBUS_SESSION_BUS_ADDRESS="unix:path=${XDG_RUNTIME_DIR}/bus"

    # Get subcommand
    subcommand=$1
    shift

    case $subcommand in
        start)
            start
            ;;
        stop)
            stop
            ;;
        build)
            build "$@"
            ;;
        status)
            status
            ;;
        run)
            run "$@"
            ;;
        exec)
            exec "$@"
            ;;
        clean)
            clean
            ;;
        help)
            show_help
            ;;
        *)
            echo "Unrecognized subcommand: $subcommand"
            exit 1
            ;;
    esac
}

trap_handler() {
    trap - SIGINT EXIT ERR

    local line_no="$1"
    local err=$2

    debug "Cleaning up ..."

    if [ $err -ne 0 ] && [ "$line_no" != "1" ]; then
        error "Error occurred on line $line_no, exit code: $err"
    fi

    debug "Exiting"

    exit $err
}

trap 'trap_handler $LINENO $?' SIGINT EXIT ERR

main "$@"
